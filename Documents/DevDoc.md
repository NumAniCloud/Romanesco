# Romanesco プラグイン開発ドキュメント

大体の内容は「予定」であり、本プロジェクトの目指す方向性を定めるものです。

## Romanesco の概要

Romanescoは.NETの型に合わせてGUIを生成するマスター データ エディターです。
プラグインにより、特定の型に対してどのようなGUIを生成するのかを変更することができます。

WPFを用いて開発されており、開発言語はC#です。
MVVMパターンを採用しており、プラグインもMVVMパターンに則ってコーディングすることができます。
逆に、MVVMパターンに詳しくなくとも開発ができるよう、パターンを意識せずコーディングする仕組みも用意しています。

## プラグインとは

Romanescoにおけるプラグインとは、RomanescoのGUI生成を拡張するためのアセンブリ ファイルです。

プラグインは以下の条件を満たしたフォルダとして管理されます：

* そのプラグインの動作を実現するDLLなどをすべて含むフォルダである。
* `Plugin.txt` という設定ファイルを含むフォルダである。

### プラグイン DLLの構造

どのようなDLLでもプラグインとして読み込まれるわけではありません。
プラグインには **エントリポイント** が必要です。

エントリポイントとは、`IPluginFacade` インターフェースを実装したクラスのことです。
詳細は後の節で解説します。

### 設定ファイルの構造

`Plugin.txt` ファイルにプラグインの設定を記述します。
その内容としては、プラグインのエントリポイントとなるDLLのファイル名を書きます。
エントリポイントが `Plugin.dll` というアセンブリ内にある場合、以下のようにします：

```
Plugin.dll
```

このように、設定ファイルはエントリポイントの名前が1行目に書かれているだけのファイルです。

### プラグインを開発する際の制限

コアのプロジェクトで `ReactiveProperty` を使用しているため、
プラグインを開発するプロジェクトでも `ReactiveProperty` パッケージを使用する必要があります。
NuGetを通じてインストールしてください。

## UIの構築過程

Romanescoは、「メンバー」をUIに変換することで編集可能にします。メンバーとは、
* プロパティ
* フィールド
* インデクサー
* その他、値を保持できる方法(サポート外)

のことです。

UIへの変換は以下の流れで行われます。
1. Romanescoがメンバーを受け取ります。
2. 受け取ったメンバーは `ValueSettability` オブジェクトにラップされます。
3. `ValueSettability` は `IFieldState` 実装オブジェクトにラップされます。
4. `IFieldState` は `IFieldStateViewModel` 実装オブジェクトにラップされます。
5. `IFieldStateViewModel` は `StateViewContext` クラスにラップされます。これがUIを含みます。

### Romanescoにメンバーが渡される

RomanescoはメンバーをGUIに変換するのであって、クラスをGUIに変換するわけではありません。
まずはじめに1つのルートのメンバーがRomanescoに渡され、
そこから子のメンバー、孫のメンバーというふうに再帰的に全てのメンバーが変換されます。

ルートのメンバーでも、その子孫のメンバーであっても、
Romanescoに渡されてからGUIに変換されます。

### ValueSettability オブジェクトへ変換される

`ValueSettability` とは、あるひとつのメンバーを表すクラスです。
フィールド・プロパティ・インデクサーなど、値を格納する機能を持つ何らかの要素を指します。
メンバーがフィールド・プロパティ・インデクサーのいずれの種類であっても、
`ValueSettability` を通じて値を設定することができ、
設定した値は最終的にオブジェクトをシリアライズする際に使います。

### IFieldState 実装オブジェクトにラップ

プラグインから提供される `IStateFactory` インターフェースの実装により、
`ValueSettability` のオブジェクトをラップする `IFieldState` のオブジェクトが生成されます。

`IFieldState` は、実際の1つのUI要素に対応付けられるインターフェースです。
MVVMパターンの **モデル** に相当するクラスが、このインターフェースを実装します。
**ドメイン モデル** と呼ぶ場合もあります。

モデルクラス自身と対応する `ValueSettability` を保持します。
自身が編集されて新しい値が代入された場合に親オブジェクトから利用します。

### IFieldStateViewModel 実装オブジェクトにラップ

プラグインから提供される `IStateViewModelFactory` インターフェースの実装により、
`IFieldState` のオブジェクトをラップする `IFieldStateViewModel` のオブジェクトが生成されます。

`IFieldStateViewModel` も、実際の1つのUI要素に対応付けられるインターフェースです。
MVVMパターンの **ビュー モデル** に相当するクラスが、このインターフェースを実装します。

ビューモデル自身と対応するモデルクラスを保持します。
ほとんどのメンバーはモデルクラスのメンバーへリダイレクトする形で実装できますが、
値の編集以外のコマンドを受け付ける機能はここで実装することを推奨します。

例えば、クラス型のメンバーを編集するためのエディターを新しいペインに開くためのボタンや、
リストに新たな要素を追加したり、要素を削除するコマンドなどです。

### StateViewContext クラスにラップ

プラグインから提供される `IViewFactory` インターフェースの実装により、
`IFieldStateViewModel` のオブジェクトを含む `StateViewContext` のオブジェクトが生成されます。

`StateViewContext` は、MVVMパターンの **ビュー** に相当するオブジェクトです。

`StateViewContext` クラスには、UIの本体と、UIのコンパクトなバージョン、
そしてビューモデル オブジェクトが保持されます。

## 設計の概略

以下の設計上の約束はプラグインを制作する際に自動的に守られるものではなく、
プラグイン制作者が少なからず意識する必要があります。

### 生のオブジェクトとUI用オブジェクト

Romanescoでは、デシリアライズ用の生のオブジェクトと、そのオブジェクトを編集するためのUIを構築するオブジェクトという、2つのオブジェクトツリーが1セットで管理されます。

ルートだけは特別で、生のオブジェクトは、UI用のオブジェクトのルートによって保持されています。
UI用のオブジェクトにおいてのルートより子孫のオブジェクトは、生のオブジェクトの一部だけを保持します。
参照としては同じものを保持しているので、子孫のオブジェクトが生のオブジェクトの一部を書き換えると、
ルートにある生のオブジェクトにも反映されます。

UI用オブジェクトがユーザーによって編集されると、生のオブジェクトへ値の変化が反映されます。
そしてシリアライズの際には、ルートにある生のオブジェクトがシリアライズされます。

### 編集されたデータを生のオブジェクトへ反映する

あるメンバーの値が編集されたとき、それを生のオブジェクトへと反映するのは、そのメンバー自身の責任ではありません。
この責任は、そのメンバーの親オブジェクトが果たします。
親オブジェクトは、子メンバーの保持している `ValueSettability` を通じて、生のオブジェクトへ値を代入します。

`ValueSettability` は値を設定するために親オブジェクトへの参照を必要とするため、
子メンバー自身には自分の値の変更を反映する手段がないので注意してください。
全てのメンバーは特定のプロパティなどを表しているので、そのプロパティを保持する親オブジェクトの参照は必須です。

また、メンバーへの編集はその1つ上の親だけに伝搬し、親が責任を持って生のオブジェクトへ反映します。
先祖要素へさかのぼってルートまで責任が伝搬することはありません。

### MVVMパターン

メンバーには、いくつかのオブジェクトが結び付けられます。具体的には、

* ValueSettability
* モデルオブジェクト
* ビューモデルオブジェクト
* ビューオブジェクト

これらのオブジェクトは、すべて1対1に対応付けられます。

## 各インターフェースの役割と実装方法

### IPluginFacade インターフェース

`IPluginFacade` インターフェースは、プラグインのエントリポイントとなるクラスが実装すべきインターフェースです。
そのプラグインが提供するファクトリー群を、プラグインローダーに登録する責任があります。

#### GetStateFactories メソッド

`IStateFactory` インターフェースの実装オブジェクトのコレクションを返すメソッドです。
ここで生成されたファクトリー クラスが、UI用のモデルオブジェクトの生成に使われます。

#### GetStateViewModelFactories メソッド

`IStateViewModelFactory` インターフェースの実装オブジェクトのコレクションを返すメソッドです。
ここで生成されたファクトリー クラスが、UI用のビューモデルオブジェクトの生成に使われます。

#### GetViewFactories メソッド

`IViewFactory` インターフェースの実装オブジェクトのコレクションを返すメソッドです。
ここで生成されたファクトリー クラスが、UI用のビューオブジェクトの生成に使われます。

### IFieldState インターフェース

モデルクラスを表すインターフェースです。
ユーザーによって入力されたコマンドを解釈するのは、このレイヤーの責務ではありません。

以下のようなメンバーを実装する必要があります。

#### Title プロパティ

UI要素を説明するラベルに使われます。

#### Content プロパティ

入力されたオブジェクトが格納されます。

通常、これ自体はデシリアライズされる値ではありません。
ルートのオブジェクトだけが特別で、
デシリアライズには、UI用のオブジェクトのルートにある `Content` プロパティの値が使われます。

#### FormattedString プロパティ

UI要素への入力値の文字列形式です。これはビューによって自由に使うことができます。
この文字列形式を常に最新の状態に更新するのは、モデルクラスの責任です。

主な用途は、リストの要素として表示することや、コンパクトな状態のUIに要約として表示することです。

#### Type プロパティ

このメンバーの型です。ビューモデルの生成などに用いられます。

#### Settability プロパティ

このメンバーに値を代入するための `ValueSettability` です。

#### OnError プロパティ

入力や解釈にエラーがあった場合はここに例外を流すと、親を伝って拾ってもらえます。
例えば、値をsetしようとしたのに該当のメンバーがprivateだった場合などに用います。

モデルで発生したエラーは、ビューモデル、ビューと辿っていき、
最後はビューのルートへ辿り着き、そこでハンドリングされます。

### IStateFactory インターフェース

`IFieldState` を生成する責務を持つインターフェースです。
ロードされた複数のプラグインから収集された `IStateFactory` は、
メンバーを `IFieldState` に変換するためにシステムから呼び出されます。

ファクトリーには優先順位があり、いつもロードされた順番でシステムから呼び出され、
あるファクトリーがモデルオブジェクトを生成したら、それ以降のファクトリーは無視されます。

#### InterpretAsState メソッド

`ValueSettability` を受け取り、それと対応する `IFieldState` を生成するインターフェースです。

渡された `ValueSettability` の型などをチェックし、それに適した `IFieldState` を生成する必要があります。
たとえば、int型のメンバーが渡された場合は `IntFieldState` というような調子です。
メンバーの型は、 `ValueSettability.Type` プロパティから取得できます。
生成された `IFieldState` は、受け取った `ValueSettability` を保持することを想定しています。

`IFieldState` は、他の `IFieldState` 実装オブジェクトを保持する必要のある場合があります。
例えば、クラス型のメンバーは他のメンバーを保持します。
そのような場合、引数として渡される `StateInterpretFunc` 型のデリゲートを用います。

`StateInterpretFunc` デリゲートにメンバーを渡すと、 `IFieldState` に変換されます。
これは再帰関数になっていますから、`InterpretAsState` をこれを呼び出すだけのメソッドとして実装すると、
無限再帰となってプログラムが停止しますので注意してください。

`StateInterpretFunc` デリゲートは、今まさにファクトリーを走査してモデルオブジェクトが生成できないか試している、
大元のメソッドが入っています。

### IStateViewModel インターフェース

ビューモデルクラスを表すインターフェースです。
ユーザーにUIを表示し編集可能にするのは、このレイヤーの責務ではありません。

主に、ビューで値が編集された、ビューでボタンが押されたなどして生じたイベントを受け取り、それを元にモデルを書き換える責務があります。

モデルオブジェクトを保持し、多くの機能をモデルへ委譲することを想定しています。

#### Title プロパティ

モデルクラスと同じもので、モデルクラスの委譲で実装すべきです。

#### Content プロパティ

モデルクラスと同じもので、モデルクラスの委譲で実装すべきです。

#### FormattedString プロパティ

モデルクラスと同じもので、モデルクラスの委譲で実装すべきです。

#### ShowDetail プロパティ (IObservable イベント)

コンパクトUIからフルUIを展開するコマンドが入力された場合、このイベントが通知されます。

ビューモデルはクラス型など複雑な型である場合があります。
一方で、UIの方は使いやすさの都合で1,2行だけのコンパクトなUIであってほしい局面もあります。

そのような場合のために、Romanescoでは「コンパクトUI」「フルUI」という2種類のUIを提供します。
基本的に、コンパクトUI上に「詳細」ボタンを設置し、
それをユーザーがクリックするとフルUIが展開される仕組みを想定しています。

Romanescoの初期状態では、クラス型のメンバーは「詳細」ボタンによってフルUIを展開するようになっています。

#### OnError プロパティ

モデルクラスと同じ機能です。
流れてきたエラーをUI用オブジェクトのルートまで到達させるためにも、
モデルクラスの `OnError` へ流れてきエラーは、このプロパティへ合流するべきです。

### ValueSettability の指すメンバーの種類は、どの時点から隠蔽されるべきか

あるメンバーがどの種類であるかは、クラスを分解するときに判明するはずである。
その分解の対象となるクラス オブジェクトは、初期化時に `IStateFactory` に入ってきて、そこで分解される。
そしてクラス オブジェクトがメンバーを持っているとき、その場で `StateInterpretFunc` に渡すはずである。
なぜならば、初期化の完了した `IFieldState` を構築するためには、
そのオブジェクトの子も全て初期化が完了している必要があるからである。

つまり、あるメンバーが指すメンバーの種類は、`IStateFactory`の内部で判明し、`IStateFactory`の内部で隠蔽される。

## メンバーを`IStateFactory`が拾ってくれなかった場合

そのメンバーが現れるべき場所には `NoneState`, `NoneStateViewModel`, `NoneView` が生成されます。

## ビルトインのUIスタイル

`Romanesco.Styles` アセンブリには、UIのデザインを揃えるために使用することのできるデフォルト スタイルがまとまっています。

これを使用するためには、まずアセンブリをプロジェクトから参照します。

その後、目的のxamlファイル内で名前空間を定義し、アセンブリの内容を使用可能にします。

```xml
<UserControl xmlns:style="clr-namespace:Romanesco.Styles.View;assembly=Romanesco.Styles">
    :
    (中略)
    :
</UserControl>
```

その後、`DynamicResource`マークアップ拡張を用いてスタイルを適用します。例えば、通常のフィールドラベルを利用するためのスタイル `TitledField` ならば、`ControlTemplate` 要素に適用します：

```xml
<ContentControl Template="{DynamicResource {ComponentResourceKey TypeInTargetAssembly={x:Type style:EditorStyles}, ResourceId=TitledField}}">
    <CheckBox IsChecked="{Binding Content.Value}"/>
</ContentControl>
```

`TitledField`の場合、チェックボックスがその場に表示されますが、左側にラベルが付与され、ラベルにはフォーカスが当たらない、他のメンバーのためのラベルと位置を揃えて表示されるなどのスタイルを利用することができます。

# 開発上の課題点

プラグイン同士で同じライブラリを使っているが、そのバージョンは互いに異なる場合はどうなるか？
[ここによると、フォルダが分かれているので大丈夫らしい](https://social.msdn.microsoft.com/Forums/vstudio/ja-JP/6ef7657c-6283-40de-9dd1-f510849d2310/12496125401247212519125311239830064123941242712450124751253112?forum=vsgeneralja)
